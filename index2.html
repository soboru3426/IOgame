<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pixel Character Movement</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #ddd;
      flex-direction: column;
    }
    .game-container {
      width: 1600px;
      height: 1600px;
      position: relative;
      overflow: hidden;
      background: url('https://i.pinimg.com/736x/d7/99/ae/d799ae2255d330b419bea813cc2aa53b.jpg') no-repeat center center;
      background-size: cover;
      border: 2px solid black;
    }
    .character-container {
      position: absolute;
      width: 55px;
      height: 115px;
      overflow: hidden;
    }
    .character {
      position: absolute;
      width: 232px;
      height: 466px;
      image-rendering: pixelated;
    }
    .monster-container {
      position: absolute;
      width: 100px;
      height: 100px;
      overflow: hidden;
    }
    .monster {
      position: absolute;
      width: 100px;
      height: 400px;
      image-rendering: pixelated;
    }
    .message {
      font-size: 32px;
      font-weight: bold;
      color: white;
      padding: 16px 28px;
      background: rgba(220, 20, 60, 0.85);
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 1000;
      animation: fadeIn 0.5s ease-out;
    }
    @keyframes fadeIn {
      0% { opacity: 0; transform: translateX(-50%) scale(0.95); }
      100% { opacity: 1; transform: translateX(-50%) scale(1); }
    }
    .skill-circle {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: rgba(0, 200, 255, 0.4);
      border: 2px solid rgba(0, 200, 255, 0.8);
      pointer-events: none;
      display: none;
      z-index: 900;
    }
    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: rgba(173, 216, 230, 0.9);
      border-radius: 50%;
      pointer-events: none;
      animation: ice-burst 1s ease-out forwards;
    }
    @keyframes ice-burst {
      0% {
        opacity: 1;
        transform: translate(0px, 0px) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--x), var(--y)) scale(0.5);
      }
    }
    .scoreboard {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 10px 16px;
      border-radius: 10px;
      font-family: sans-serif;
      font-size: 16px;
      z-index: 1001;
    }
    
      .hp-bar-container {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 200px;
      height: 24px;
      border: 2px solid black;
      background-color: #ddd;
      z-index: 1001;
    }

      .hp-bar {
      height: 100%;
      width: 100%;
      background-color: crimson;
      transition: width 0.3s ease;
    }

    .monster-hp-bar-container {
      position: absolute;
      bottom: -8px;
      left: 0;
      width: 100%;
      height: 4px;
      background-color: #444;
      border-radius: 2px;
      overflow: hidden;
    }

    .monster-hp-bar {
      width: 100%;
      height: 100%;
      background-color: #ff0000;
      transition: width 0.3s ease;
    }
    .skill-effect {
     position: absolute;
     width: 180px;
     height: auto;
     pointer-events: none;
     z-index: 900;
    }

    
    .skill-icon-container {
      position: fixed;
      top: 40px; /* HPë°” ì•„ë˜ë¡œ */
      left: 10px;
      width: 40px;
      height: 40px;
      z-index: 1000;
    }

    .skill-icon {
      width: 100%;
      height: 100%;
      border: 2px solid black;
      border-radius: 6px;
    }

    .skill-cooldown {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      top: 0;
      left: 0;
      border-radius: 6px;
      pointer-events: none;
      z-index: 2;
      transition: height 0.1s linear;
    }

    .boss-hp-container {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 400px;
  height: 30px;
  background-color: #333;
  border: 3px solid #000;
  border-radius: 15px;
  z-index: 1002;
  display: none;
}

.boss-hp-bar {
  height: 100%;
  width: 100%;
  background-color: #ff4500;
  transition: width 0.3s ease;
  border-radius: 12px;
}

.boss-hp-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-weight: bold;
  text-shadow: 2px 2px 2px black;
}

.boss-container {
  position: absolute;
  width: 200px;   /* í•œ í”„ë ˆì„ì˜ ë„ˆë¹„ */
  height: 1000px;  /* í•œ í”„ë ˆì„ì˜ ë†’ì´ */
  overflow: hidden;
  z-index: 999;
}

.boss {
  position: absolute;
  width: 800px;   /* 200px * 4í”„ë ˆì„ (ê°€ë¡œ ë°°ì—´) */
  height: 800px;  /* í•œ í”„ë ˆì„ì˜ ë†’ì´ */
  image-rendering: pixelated;
}
/* ëª¨ë‹¬(ëŒ€í™”ì°½) ê¸°ë³¸ ìŠ¤íƒ€ì¼ */
.dialogue-box {
  position: fixed; /* í™”ë©´ ê³ ì • */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  
  width: 400px;
  background-color: #f7f7f7;
  border: 3px solid #000;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  
  display: none; /* ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
  z-index: 9999; /* ìµœìƒìœ„ì— í‘œì‹œ */
  font-family: sans-serif;
}

/* ëŒ€í™”ì°½ ë‚´ë¶€ êµ¬ì¡° */
.dialogue-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #ffd9e8; /* ì—°í•œ ë¶„í™ìƒ‰ */
  padding: 10px;
  border-bottom: 2px solid #000;
}

.dialogue-header span {
  font-weight: bold;
  font-size: 1.1rem;
}

.dialogue-header button {
  background: none;
  border: none;
  font-size: 1rem;
  cursor: pointer;
  padding: 5px;
}

.dialogue-content {
  padding: 15px;
  line-height: 1.4;
  min-height: 100px;
}

.dialogue-footer {
  text-align: right;
  border-top: 2px solid #000;
  padding: 10px;
}

.dialogue-footer button {
  cursor: pointer;
  padding: 6px 12px;
  margin-left: 5px;
}

.dialogue-footer button:hover {
  background-color: #eee;
}



    .weapon {
  position: absolute;
  width: 90px;
  height: auto;
  image-rendering: pixelated;
  pointer-events: none;
  transform-origin: 75% 95%;
  z-index: 1;
}

  </style>
</head>
<body>
    <div class="message" id="message">ğŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤ ğŸ’€</div>
    <div class="scoreboard" id="scoreboard">
      Kills: <span id="killCount">0</span> | Time Left: <span id="timer">3:00</span>
    </div>
    <div class="game-container" id="gameContainer">
      <!-- ìºë¦­í„°ëŠ” ì—¬ê¸° -->
      <div class="character-container" id="charContainer">
        <img class="character" id="character" src="./killyou2.png" alt="character sprite" />
      </div>
    
      <!-- ë¬´ê¸°ëŠ” ìºë¦­í„° ë°–ìœ¼ë¡œ! -->
      <img class="weapon" id="weapon" src="./kimremove.png" alt="weapon" />
    
    
      <div class="monster-container" id="monster0">
        <img class="monster" src="./gorlia.png" alt="monster" />
      </div>
      <div class="monster-container" id="monster1">
        <img class="monster" src="./gorlia.png" alt="monster" />
      </div>
      <div class="dialogue-box" id="dialogueBox">
        <div class="dialogue-header">
          <span>ê³ ë¦´ë¼</span>
          <button id="closeBtn">X</button>
        </div>
        <div class="dialogue-content">
          <p><br />
          ìš°ê°€ê°€ìš°ê°€? (ìƒˆë¡œìš´ ëª¨í—˜ê°€ì¸ê°€?)<br />
          â€¢ ì²« í€˜ìŠ¤íŠ¸</p>
        </div>
        <div class="dialogue-footer">
          <button id="nextBtn">ë‹¤ìŒ</button>
        </div>
      </div>
      <!-- ë³´ìŠ¤ ì²´ë ¥ë°” -->
      <div class="boss-hp-container" id="bossHpContainer" style="display: none;">
        <div class="boss-hp-bar" id="bossHpBar"></div>
        <div class="boss-hp-text" id="bossHpText"></div>
      </div>

      <!-- ë³´ìŠ¤ ëª¬ìŠ¤í„° -->
      <div class="boss-container" id="bossContainer" style="display: none;">
        <img class="boss" src="./boss.png" alt="boss" />
      </div>
    
      <!-- âœ… ìš”ê¸°! skillEffect ì´ë¯¸ì§€ ì¶”ê°€ -->
      <img id="skillEffect" src="./skill2-remove.png" class="skill-effect" style="display: none;" />
      <img
        id="skillEffect2"
        src="./skill2.gif"
        style="position: absolute; display: none; width: 300px; height: 300px;"
        alt="Skill 2 Effect Animation"
      />
      <img
        id="skillEffect3"
        src="./skill3.gif"
        style="position: absolute; display: none; width: 300px; height: 300px;"
        alt="Skill 3 Effect Animation"
      />

    
      <!-- ê¸°ì¡´ CSS ê¸°ë°˜ ì›í˜• ì´í™íŠ¸ëŠ” ì œê±°í•˜ê±°ë‚˜ ìœ ì§€ -->
      <div class="skill-circle" id="skillCircle" style="display: none;"></div>
    </div>
  
    <div id="gameOverUI" style="display: none; flex-direction: column; align-items: center; gap: 12px; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1001;">
      <div style="display: flex; gap: 16px;">
        <button id="restartBtn" style="padding: 10px 20px; font-size: 16px;">Start</button>
        <button id="exitBtn" style="padding: 10px 20px; font-size: 16px;">Exit</button>
      </div>
    </div>
   
  
    <div class="hp-bar-container">
      <div class="hp-bar" id="hpBar"></div>
    </div>
    <div class="skill-icon-container">
      <div class="skill-cooldown" id="skillCooldown"></div>
      <img src="./icon.png" alt="skill icon" class="skill-icon" />
      <div id="skillCooldown2" id="skillCooldown2"></div>
      <img src="./icon2.png" alt="skill2 icon" class="skill-icon"/>
    </div>
    

    <script>
      const skillEffect = document.getElementById("skillEffect"); // âœ… ì´ë¯¸ì§€ ì´í™íŠ¸
      const skillCircle = document.getElementById("skillCircle"); // (ë” ì´ìƒ ì‚¬ìš© X)
      const message = document.getElementById("message");
      const gameOverUI = document.getElementById("gameOverUI");
      const restartBtn = document.getElementById("restartBtn");
      const exitBtn = document.getElementById("exitBtn");
      const killDisplay = document.getElementById("killCount");
      const timerDisplay = document.getElementById("timer");
      const character = document.getElementById("character");
      const weapon = document.getElementById("weapon");
      const gameContainer = document.getElementById("gameContainer");
      const gameWidth = gameContainer.clientWidth;
      const gameHeight = gameContainer.clientHeight;
      const skillEffect3 = document.getElementById("skillEffect3");
      const skillCooldown3 = document.getElementById("skillCooldown3");
      const MONSTER_COUNT = 100; // ëª¬ìŠ¤í„° ìˆ˜ ì¦ê°€
      const skillEffect2 = document.getElementById("skillEffect2"); // ìƒˆë¡œìš´ ìŠ¤í‚¬ ì´í™íŠ¸ ì´ë¯¸ì§€ (300x300 ê·œê²©)
      const skillCooldown2 = document.getElementById("skillCooldown2");
      const monster1 = document.getElementById('monster1');
      const dialogueBox = document.getElementById('dialogueBox');
      const closeBtn = document.getElementById('closeBtn');
      const nextBtn = document.getElementById('nextBtn');
      const monsters = [];
      const boss = {
        container: document.getElementById("bossContainer"),
        sprite: document.querySelector(".boss"),
        hpContainer: document.getElementById("bossHpContainer"),
        hpBar: document.getElementById("bossHpBar"),
        hpText: document.getElementById("bossHpText"),
        x: 800,  // ì¤‘ì•™ ì¢Œí‘œ
        y: 800,
        maxHealth: 1000,
        currentHealth: 1000,
        alive: false
      };
    
      let posX = 368, posY = 268;
      let speed = 48;
      let frame = 0;
      let directionY = 0;
      let isInvincible = false;
      let canUseSkill = true;
      let canUseSkill2 = true;
      let canUseSkill3 = true;
      let killCount = 0;
      let remainingTime = 180;
      let timerInterval;
      let bossSpawned = false;
      let currentHP = 100, maxHP = 100;
    

    
      monster1.addEventListener('click', () => {
    dialogueBox.style.display = 'block';
  });

  // ë‹«ê¸° ë²„íŠ¼
  closeBtn.addEventListener('click', () => {
    dialogueBox.style.display = 'none';
  });

  // 'ë‹¤ìŒ' ë²„íŠ¼(ì¶”ê°€ ê¸°ëŠ¥ ì˜ˆì‹œ)
  nextBtn.addEventListener('click', () => {
    // ëŒ€í™” ë‚´ìš©ì„ ë³€ê²½í•˜ê±°ë‚˜, ë‹¤ë¥¸ ëŒ€í™”ì°½ì„ ë„ìš°ëŠ” ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
    alert('ë‹¤ìŒ ëŒ€í™”ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤!');
  });
          // âœ… ë¬´ê¸° ìœ„ì¹˜ë¥¼ .character-container ë°–ì—ì„œ ì •í™•íˆ ìœ„ì¹˜ì‹œí‚¤ë„ë¡ ìˆ˜ì •ëœ ì „ì²´ updateCharacter()
function updateCharacter() {
  const charContainer = document.getElementById("charContainer");
  const weaponEl = document.getElementById("weapon");

  // ì•ˆì „ ì²´í¬
  if (!charContainer || !weaponEl || !gameContainer) return;

  charContainer.style.left = posX + "px";
  charContainer.style.top = posY + "px";
  character.style.transform = `translate(${-frame * 58}px, ${-directionY * 117}px)`;

  // ì¢Œí‘œ ê³„ì‚°
  const gameRect = gameContainer.getBoundingClientRect();
  const charRect = charContainer.getBoundingClientRect();

  const baseX = charRect.left - gameRect.left;
  const baseY = charRect.top - gameRect.top;

  // ë¬´ê¸° ìœ„ì¹˜ ì—…ë°ì´íŠ¸
  weaponEl.style.position = "absolute";
  weaponEl.style.transformOrigin = "75% 95%";

  if (directionY === 0) { // â†“ ì•„ë˜
    weaponEl.style.left = (baseX - 40) + "px";
    weaponEl.style.top = (baseY + 7) + "px";
    weaponEl.style.transform = "rotate(45deg)";
  } else if (directionY === 1) { // â†‘ ìœ„
    weaponEl.style.left = (baseX - 30) + "px";
    weaponEl.style.top = (baseY - 30) + "px";
    weaponEl.style.transform = "rotate(135deg)";
  } else if (directionY === 2) { // â† ì™¼ìª½
    weaponEl.style.left = (baseX - 42) + "px";
    weaponEl.style.top = (baseY + 18) + "px";
    weaponEl.style.transform = "rotate(5deg)";
  } else if (directionY === 3) { // â†’ ì˜¤ë¥¸ìª½
    weaponEl.style.left = (baseX - 30) + "px";
    weaponEl.style.top = (baseY + 18) + "px";
    weaponEl.style.transform = "scaleX(-1) rotate(-5deg)";
  }
}
function updateBossHealth() {
  const percent = (boss.currentHealth / boss.maxHealth) * 100;
  boss.hpBar.style.width = percent + "%";
  boss.hpText.textContent = `${Math.floor(percent)}%`;
}

// ë³´ìŠ¤ ìŠ¤í° í•¨ìˆ˜
function spawnBoss() {
  bossSpawned = true;
  boss.alive = true;
  boss.currentHealth = boss.maxHealth;
  boss.container.style.display = 'block';
  boss.hpContainer.style.display = 'block';
  updateBossHealth();
  
  // í™”ë©´ ê°€ì¥ìë¦¬ë¥¼ í”¼í•˜ëŠ” ëœë¤í•œ ìœ„ì¹˜ì— ìŠ¤í° (ì˜ˆ: ìµœì†Œ 200, ìµœëŒ€ gameWidth-200 ë“±)
  boss.x = Math.random() * (gameWidth - 400) + 200;
  boss.y = Math.random() * (gameHeight - 400) + 200;
  boss.container.style.left = boss.x + "px";
  boss.container.style.top = boss.y + "px";
  
  // ì´ˆê¸° ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ 0 ì„¤ì •
  boss.frame = 0;
  // boss.pngëŠ” ê°€ë¡œ ë°°ì—´ì´ë¯€ë¡œ translateX ì‚¬ìš© (ê° í”„ë ˆì„ì˜ ë„ˆë¹„: 200px)
  boss.sprite.style.transform = `translateX(${-boss.frame * 200}px)`;
}





      
    
      function updateHPBar() {
        const hpBar = document.getElementById("hpBar");
        hpBar.style.width = (currentHP / maxHP * 100) + "%";
      }
    
      function updateMonsters() {
        monsters.forEach(mon => {
          if (!mon.alive) return;
          const dx = posX - mon.x;
          const dy = posY - mon.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
    
          if (dist < 150) {
            mon.chasing = true;
            mon.frame = (mon.frame + 1) % 3 + 1;
          } else if (dist > 200) {
            mon.chasing = false;
            mon.frame = 0;
          }
    
          mon.container.style.left = mon.x + "px";
          mon.container.style.top = mon.y + "px";
          mon.sprite.style.transform = `translateY(${-mon.frame * 100}px)`;
        });
      }
    
      function moveMonsters() {
  monsters.forEach(mon => {
    if (!mon.alive) return;
    const dx = posX - mon.x;
    const dy = posY - mon.y;

    if (mon.chasing) {
      mon.x += Math.sign(dx) * 20;
      mon.y += Math.sign(dy) * 20;
    } else {
      mon.x += (Math.random() - 0.5) * 50;
      mon.y += (Math.random() - 0.5) * 50;
    }

    mon.x = Math.max(0, Math.min(gameWidth - 100, mon.x));
    mon.y = Math.max(0, Math.min(gameHeight - 100, mon.y));
  });
  
  if (boss.alive) {
    const dx = posX - boss.x;
    const dy = posY - boss.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    boss.frame = (boss.frame + 1) % 4;
    boss.sprite.style.transform = `translateY(${-boss.frame * 200}px)`; // í”„ë ˆì„ ë†’ì´ ì¡°ì •
    
    // ëª¬ìŠ¤í„°ì™€ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ ë³´ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ë° ì´ë™ ì²˜ë¦¬
    if (boss.alive) {
    const dx = posX - boss.x;
    const dy = posY - boss.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // í”Œë ˆì´ì–´ê°€ ê°€ê¹Œìš°ë©´ ë³´ìŠ¤ëŠ” í•­ìƒ ë§ˆì§€ë§‰ ì»·(ì¸ë±ìŠ¤ 3)ì„ ë³´ì—¬ì¤€ë‹¤.
    if (dist < 300) {
      boss.chasing = true;
      boss.frame = 3;
      boss.x += Math.sign(dx) * 8; // ë³´ìŠ¤ ì´ë™ ì†ë„ëŠ” ëŠë¦¬ê²Œ
      boss.y += Math.sign(dy) * 8;
    } else {
      boss.chasing = false;
      // ì¼ë°˜ ìƒí™©ì—ì„œëŠ” í”„ë ˆì„ì´ í•œ ì»·ì”© ë²ˆê°ˆì•„ ë‚˜ì˜¤ë„ë¡ ì²˜ë¦¬.
      boss.frame = (boss.frame + 1) % 4;
      boss.x += (Math.random() - 0.5) * 10;
      boss.y += (Math.random() - 0.5) * 10;
    }
    
    // ë³´ìŠ¤ì˜ ìœ„ì¹˜ ì œí•œ
    boss.x = Math.max(100, Math.min(gameWidth - 300, boss.x));
    boss.y = Math.max(100, Math.min(gameHeight - 300, boss.y));
    boss.container.style.left = boss.x + "px";
    boss.container.style.top = boss.y + "px";
    
    // ë³´ìŠ¤ ì• ë‹ˆë©”ì´ì…˜: ê°€ë¡œ ë°°ì—´ì´ë¯€ë¡œ ê° í”„ë ˆì„ì˜ ë„ˆë¹„ 200px ì‚¬ìš©  
    boss.sprite.style.transform = `translateX(${-boss.frame * 200}px)`;
  }

  updateMonsters();
  checkCollision();
}
updateMonsters();
  checkCollision();
}

    
      function checkCollision() {
        const charRect = character.parentElement.getBoundingClientRect();
        for (let mon of monsters) {
          if (!mon.alive) continue;
          const monRect = mon.container.getBoundingClientRect();
          if (
            charRect.left < monRect.right &&
            charRect.right > monRect.left &&
            charRect.top < monRect.bottom &&
            charRect.bottom > monRect.top
          ) {
            if (!isInvincible) {
              currentHP -= 20;
              updateHPBar();
    
              if (currentHP <= 0) {
                message.textContent = "ğŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤ ğŸ’€";
                message.style.display = "block";
                setTimeout(resetCharacter, 1000);
              } else {
                isInvincible = true;
                setTimeout(() => { isInvincible = false; }, 2500);
              }
            }
          }
        }
        if (boss.alive) {
    const bossRect = boss.container.getBoundingClientRect();
    if (
      charRect.left < bossRect.right &&
      charRect.right > bossRect.left &&
      charRect.top < bossRect.bottom &&
      charRect.bottom > bossRect.top
    ) {
      if (!isInvincible) {
        currentHP -= 40;  // ë³´ìŠ¤ëŠ” ë” í° ë°ë¯¸ì§€
        updateHPBar();
        
        if (currentHP <= 0) {
          message.textContent = "ğŸ’€ ì£½ì—ˆìŠµë‹ˆë‹¤ ğŸ’€";
          message.style.display = "block";
          setTimeout(resetCharacter, 1000);
        } else {
          isInvincible = true;
          setTimeout(() => { isInvincible = false; }, 2500);
        }
      }
    }
      }
    }
    
      function resetCharacter() {
        const safeDistance = 300;
        let safe = false;
        let attempt = 0;
    
        while (!safe && attempt < 100) {
          attempt++;
          let tryX = Math.random() * (gameWidth - 58);
          let tryY = Math.random() * (gameHeight - 117);
    
          safe = monsters.every(mon => {
            const dx = tryX - mon.x;
            const dy = tryY - mon.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist >= safeDistance;
          });
    
          if (safe) {
            posX = tryX;
            posY = tryY;
          }
        }
    
        currentHP = maxHP;
        updateHPBar();
        updateCharacter();
        isInvincible = true;
        setTimeout(() => { isInvincible = false; }, 2500);
        message.style.display = "none";
      }
    
      function createIceParticles(x, y) {
        for (let i = 0; i < 20; i++) {
          const p = document.createElement("div");
          p.className = "particle";
          p.style.left = x + "px";
          p.style.top = y + "px";
          const angle = Math.random() * 2 * Math.PI;
          const radius = 40 + Math.random() * 100;
          p.style.setProperty("--x", Math.cos(angle) * radius + "px");
          p.style.setProperty("--y", Math.sin(angle) * radius + "px");
          p.style.width = "12px";
          p.style.height = "12px";
          p.style.backgroundColor = "rgba(0, 255, 255, 0.85)";
          p.style.boxShadow = "0 0 4px white";
    
          gameContainer.appendChild(p);
          setTimeout(() => gameContainer.removeChild(p), 1500);
        }
      }
      function createMonster() {
  const container = document.createElement("div");
  container.className = "monster-container";
  
  const sprite = document.createElement("img");
  sprite.className = "monster";
  sprite.src = "./gorlia.png";

  
  
  const hpBarContainer = document.createElement("div");
  hpBarContainer.className = "monster-hp-bar-container";
  
  const hpBar = document.createElement("div");
  hpBar.className = "monster-hp-bar";
  hpBarContainer.appendChild(hpBar);
  
  container.appendChild(sprite);
  container.appendChild(hpBarContainer);
  gameContainer.appendChild(container);

  return {
    container,
    sprite,
    hpBar,
    x: Math.random() * (gameWidth - 100),
    y: Math.random() * (gameHeight - 100),
    frame: 0,
    chasing: false,
    alive: true,
    maxHealth: 100,
    currentHealth: 100
  };
}
for (let i = 0; i < MONSTER_COUNT; i++) {
  monsters.push(createMonster());
}

function updateMonsterHealthBar(mon) {
  mon.hpBar.style.width = `${(mon.currentHealth / mon.maxHealth) * 100}%`;
}
    
      const skillCooldown = document.getElementById("skillCooldown"); // âœ… ì•„ì´ì½˜ ì¿¨íƒ€ì„ ë§ˆìŠ¤í¬
      let cooldownDuration = 10; // 1ì´ˆ ì¿¨íƒ€ì„

      function useSkill() {
        canUseSkill = false;

        const stabX = posX + 29;
        const stabY = posY + 58;
        let x = stabX, y = stabY;

        if (directionY === 0) { // â†“ ì•„ë˜
          x -= 90;
          y += 40;
          skillEffect.style.transform = "rotate(270deg)";
        } else if (directionY === 1) { // â†‘ ìœ„
          x -= 100;
          y -= 100;
          skillEffect.style.transform = "rotate(90deg)";
        } else if (directionY === 2) { // â† ì™¼ìª½
          x -= 140;
          y -= 30;
          skillEffect.style.transform = "rotate(0deg)";
        } else if (directionY === 3) { // â†’ ì˜¤ë¥¸ìª½
          x -= 20;
          y -= 40;
          skillEffect.style.transform = "rotate(180deg)";
        }

        skillEffect.style.left = x + "px";
        skillEffect.style.top = y + "px";
        skillEffect.style.display = "block";

        const effectW = 280; // ì‹œê°ì ìœ¼ë¡œ ê¸¸ê²Œ!
        const effectH = 280; // ë†’ì´ë„ ì—¬ìœ  ìˆê²Œ
        if (boss.alive) {
          const bossRect = boss.container.getBoundingClientRect();
          const gameRect = gameContainer.getBoundingClientRect();
          
          // ê²Œì„ ì»¨í…Œì´ë„ˆ ê¸°ì¤€ ì¢Œí‘œë¡œ ë³€í™˜
          const bossX = bossRect.left - gameRect.left;
          const bossY = bossRect.top - gameRect.top;

          if (
            bossX + 75 >= x && bossX <= x + effectW &&  // ì¤‘ì•™ ê¸°ì¤€ ì¶©ëŒ ì²´í¬
            bossY + 75 >= y && bossY <= y + effectH
          ) {
            boss.currentHealth -= 50;  // ë°ë¯¸ì§€ ì¦ê°€
            updateBossHealth();
            
            if (boss.currentHealth <= 0) {
              boss.alive = false;
              boss.container.style.display = 'none';
              boss.hpContainer.style.display = 'none';
              killCount += 50;  // 50ì  ì¶”ê°€ë¡œ ìˆ˜ì •
              killDisplay.textContent = killCount;
              createIceParticles(bossX + 75, bossY + 75);
            }
          }
        }


        monsters.forEach(mon => {
          const mx = mon.x + 50;
          const my = mon.y + 50;
          if (
            mx >= x && mx <= x + effectW &&
            my >= y && my <= y + effectH
          ) {
            mon.currentHealth -= 50; // ë°ë¯¸ì§€ 50 ì ìš©
            updateMonsterHealthBar(mon);
            mon.alive = false;
            mon.container.style.display = "none";
            createIceParticles(mx, my);
            killCount++;
            killDisplay.textContent = killCount;
            

            setTimeout(() => {
              mon.x = Math.random() * (gameWidth - 100);
              mon.y = Math.random() * (gameHeight - 100);
              mon.frame = 0;
              mon.chasing = false;
              mon.alive = true;
              mon.container.style.display = "block";
            }, 1500);
          }
          if (mon.currentHealth <= 0) {
        mon.alive = false;
        mon.container.style.display = "none";
        // ... ê¸°ì¡´ ì²˜ì¹˜ íš¨ê³¼
        
        setTimeout(() => {
          mon.currentHealth = mon.maxHealth;
          updateMonsterHealthBar(mon);
          // ... ê¸°ì¡´ ë¦¬ìŠ¤í° ë¡œì§
        }, 1500);
      }
        });
        if (boss.alive) {
    const bossRect = boss.container.getBoundingClientRect();
    const bossCenterX = bossRect.left + bossRect.width/2;
    const bossCenterY = bossRect.top + bossRect.height/2;
    
    if (
      bossCenterX >= x && bossCenterX <= x + effectW &&
      bossCenterY >= y && bossCenterY <= y + effectH
    ) {
      boss.currentHealth -= 30; // ì¼ë°˜ ëª¹ë³´ë‹¤ ì ì€ ë°ë¯¸ì§€
      updateBossHealth();
      
      if (boss.currentHealth <= 0) {
        boss.alive = false;
        boss.container.style.display = 'none';
        boss.hpContainer.style.display = 'none';
        killCount += 5; // ë³´ìŠ¤ ì²˜ì¹˜ ë³´ìƒ
        killDisplay.textContent = killCount;
        createIceParticles(bossCenterX, bossCenterY);
      }
    }
  }
  if (killCount >= 50 && !bossSpawned) {
    spawnBoss();
  }

        setTimeout(() => {
          skillEffect.style.display = "none";
        }, 200);

        // âœ… ì¿¨íƒ€ì„ ì‹œê° íš¨ê³¼
        skillCooldown.style.height = "100%";
        let elapsed = 0;
        const cooldownInterval = setInterval(() => {
          elapsed += 100;
          const percent = Math.max(0, 100 - (elapsed / cooldownDuration) * 100);
          skillCooldown.style.height = percent + "%";

          if (elapsed >= cooldownDuration) {
            clearInterval(cooldownInterval);
            skillCooldown.style.height = "0%";
          }
        }, 100);

        // âœ… ìŠ¤í‚¬ ì¿¨íƒ€ì„
        setTimeout(() => { canUseSkill = true; }, cooldownDuration);
      }
      restartBtn.addEventListener("click", () => {
  // ... ê¸°ì¡´ ì½”ë“œ
  bossSpawned = false;
  boss.alive = false;
  boss.container.style.display = 'none';
  boss.hpContainer.style.display = 'none';
      });
      function useSkill3() {
        // ìŠ¤í‚¬ ì‚¬ìš© ë¶ˆê°€ ìƒíƒœë¡œ ì „í™˜
        canUseSkill3 = false;
        
        // ìºë¦­í„° ì¤‘ì‹¬ ì¢Œí‘œ (posXì™€ posYëŠ” ìºë¦­í„°ì˜ ì¢Œì¸¡ ìƒë‹¨; ìºë¦­í„° í¬ê¸°ê°€ 58Ã—117ì´ë¯€ë¡œ ì¤‘ì‹¬ì€ posX+29, posY+58)
        const startCX = posX + 29;
        const startCY = posY + 58;
        
        // ëŒ€ì‹œ(ìŠ¤í‚¬3) ì´ë™ ê±°ë¦¬ (ì˜ˆ: 150px)
        const dashDistance = 150;
        let dx = 0, dy = 0, rotation = 0;
        
        // directionY: 0: ì•„ë˜, 1: ìœ„, 2: ì™¼ìª½, 3: ì˜¤ë¥¸ìª½  
        // (ìŠ¤í‚¬ GIFëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì™¼ìª½ì„ í–¥í•¨)
        if (directionY === 2) { // ì™¼ìª½
          dx = -dashDistance;
          rotation = 0;
        } else if (directionY === 3) { // ì˜¤ë¥¸ìª½
          dx = dashDistance;
          rotation = 180;
        } else if (directionY === 1) { // ìœ„ìª½
          dy = -dashDistance;
          rotation = 90;
        } else if (directionY === 0) { // ì•„ë˜ìª½
          dy = dashDistance;
          rotation = 270;
        }
        
        // ìµœì¢… ìºë¦­í„° ì¤‘ì‹¬ ì¢Œí‘œ
        const endCX = startCX + dx;
        const endCY = startCY + dy;
        
        // ìŠ¤í‚¬ ì´í™íŠ¸ í‘œì‹œ: íš¨ê³¼ ì´ë¯¸ì§€ë¥¼ ìºë¦­í„°ì˜ ì‹œì‘ ì¤‘ì‹¬ì— ë§ì¶”ì–´ í‘œì‹œ.
        // íš¨ê³¼ ì´ë¯¸ì§€ í¬ê¸°ê°€ 300Ã—300ì´ë¯€ë¡œ, ì¢Œìƒë‹¨ ì¢Œí‘œëŠ” (center - 150)
        const effectX = startCX - 110;
        const effectY = startCY - 110;
        skillEffect3.style.left = effectX + "px";
        skillEffect3.style.top = effectY + "px";
        // íšŒì „: ê¸°ë³¸ GIFëŠ” ì™¼ìª½ì„ í–¥í•˜ë¯€ë¡œ, ë°”ë¼ë³´ëŠ” ë°©í–¥ì— ë§ê²Œ íšŒì „  
        skillEffect3.style.transform = `rotate(${rotation}deg)`;
        skillEffect3.style.display = "block";
        
        // **ëŒ€ì‹œ ì²˜ë¦¬:**  
        // ìºë¦­í„°ì˜ ìµœì¢… ì¢Œì¸¡ ìƒë‹¨ ì¢Œí‘œë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        // (ìºë¦­í„° ì¤‘ì‹¬ = posX + 29, posY + 58 â†’ ë”°ë¼ì„œ ìƒˆë¡œìš´ posX = endCX - 29, posY = endCY - 58)
        posX = endCX - 29;
        posY = endCY - 58;
        updateCharacter();
        
        // **ëŒ€ì‹œ ê²½ë¡œ ì¶©ëŒ ì²˜ë¦¬:**  
        // ëŒ€ì‹œ ê²½ë¡œëŠ” ì‹œì‘ ì¤‘ì‹¬ê³¼ ë ì¤‘ì‹¬ì„ ì‡ëŠ” ì„ ë¶„ì˜ ì£¼ë³€ì„ ë®ëŠ” ì§ì‚¬ê°í˜• ì˜ì—­ìœ¼ë¡œ ì •ì˜í•©ë‹ˆë‹¤.
        const dashWidth = 100; // ê²½ë¡œ í­ (ì˜ˆì‹œ)
        const dashMinX = Math.min(startCX, endCX) - dashWidth / 2;
        const dashMaxX = Math.max(startCX, endCX) + dashWidth / 2;
        const dashMinY = Math.min(startCY, endCY) - dashWidth / 2;
        const dashMaxY = Math.max(startCY, endCY) + dashWidth / 2;
        
        // ëª¬ìŠ¤í„° ì¶©ëŒ ì²˜ë¦¬: ê° ëª¬ìŠ¤í„° ì¤‘ì‹¬ì´ ëŒ€ì‹œ ì˜ì—­ ì•ˆì— ìˆëŠ”ì§€ ì²´í¬
        monsters.forEach(mon => {
          const monCX = mon.x + 50; // ëª¬ìŠ¤í„° ì¤‘ì‹¬ (ì˜ˆì‹œ, ì¡°ì • í•„ìš”)
          const monCY = mon.y + 50;
          if (monCX >= dashMinX && monCX <= dashMaxX &&
              monCY >= dashMinY && monCY <= dashMaxY) {
            // ë°ë¯¸ì§€ ì ìš© (ì˜ˆ: 100 ë°ë¯¸ì§€)
            mon.currentHealth -= 100;
            updateMonsterHealthBar(mon);
            if (mon.currentHealth <= 0) {
              mon.alive = false;
              mon.container.style.display = "none";
              killCount++;
              killDisplay.textContent = killCount;
              createIceParticles(monCX, monCY);
              // ì¼ì • ì‹œê°„ í›„ ë¦¬ìŠ¤í° ì²˜ë¦¬
              setTimeout(() => {
                mon.x = Math.random() * (gameWidth - 100);
                mon.y = Math.random() * (gameHeight - 100);
                mon.frame = 0;
                mon.chasing = false;
                mon.currentHealth = mon.maxHealth;
                mon.alive = true;
                mon.container.style.display = "block";
              }, 1500);
            }
          }
        });
        
        // ë³´ìŠ¤ ì¶©ëŒ ì²˜ë¦¬: ë³´ìŠ¤ ì¤‘ì‹¬ì´ ëŒ€ì‹œ ì˜ì—­ ë‚´ì— ìˆìœ¼ë©´ ë°ë¯¸ì§€ ì ìš©
        if (boss.alive) {
          const bossRect = boss.container.getBoundingClientRect();
          const gameRect = gameContainer.getBoundingClientRect();
          const bossCenterX = bossRect.left - gameRect.left + bossRect.width / 2;
          const bossCenterY = bossRect.top - gameRect.top + bossRect.height / 2;
          if (bossCenterX >= dashMinX && bossCenterX <= dashMaxX &&
              bossCenterY >= dashMinY && bossCenterY <= dashMaxY) {
            boss.currentHealth -= 100;
            updateBossHealth();
            if (boss.currentHealth <= 0) {
              boss.alive = false;
              boss.container.style.display = 'none';
              boss.hpContainer.style.display = 'none';
              killCount += 5;
              killDisplay.textContent = killCount;
              createIceParticles(bossCenterX, bossCenterY);
            }
          }
        }
        
        // ìŠ¤í‚¬ ì´í™íŠ¸ëŠ” 200ms í›„ ìˆ¨ê¹€ ì²˜ë¦¬
        setTimeout(() => {
          skillEffect3.style.display = "none";
        }, 800);
        
        // ì¿¨ë‹¤ìš´ ì‹œê° íš¨ê³¼ ì²˜ë¦¬ (ì˜ˆ: 3ì´ˆ ì¿¨ë‹¤ìš´)
        skillCooldown3.style.height = "100%";
        let elapsed3 = 0;
        const cooldownInterval3 = setInterval(() => {
          elapsed3 += 100;
          const percent = Math.max(0, 100 - (elapsed3 / cooldownDuration) * 100);
          skillCooldown3.style.height = percent + "%";
          if (elapsed3 >= cooldownDuration) {
            clearInterval(cooldownInterval3);
            skillCooldown3.style.height = "0%";
          }
        }, 100);
        if (killCount >= 50 && !bossSpawned) {
    spawnBoss();
  }
        // ì¿¨ë‹¤ìš´ ì§€ì† í›„ ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥
        setTimeout(() => { canUseSkill3 = true; }, cooldownDuration);
      }





      function useSkill2() {
          // ìŠ¤í‚¬ ì‚¬ìš© ë¶ˆê°€ ìƒíƒœë¡œ ì „í™˜
          canUseSkill2 = false;
          
          // ìºë¦­í„° ì¤‘ì‹¬ ì¢Œí‘œ (ê¸°ì¡´ ì½”ë“œ ê¸°ì¤€, posXì™€ posYëŠ” ìºë¦­í„° ìœ„ì¹˜ ì¢Œì¸¡ ìƒë‹¨)
          const centerX = posX + 29;
          const centerY = posY + 58;
          
          // ìŠ¤í‚¬ íš¨ê³¼ ì˜ì—­: 300x300, ìºë¦­í„° ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ í•˜ë¯€ë¡œ,
          // ì¢Œì¸¡ ìƒë‹¨ ì¢Œí‘œëŠ” ì¤‘ì‹¬ì—ì„œ 150pxì”© ë¹¼ë©´ ë©ë‹ˆë‹¤.
          const effectX = centerX - 150;
          const effectY = centerY - 150;
          
          // ìŠ¤í‚¬ ì´í™íŠ¸ ì´ë¯¸ì§€ë¥¼ í•´ë‹¹ ìœ„ì¹˜ì— í‘œì‹œ
          skillEffect2.style.left = effectX + "px";
          skillEffect2.style.top = effectY + "px";
          skillEffect2.style.display = "block";
          
          // íš¨ê³¼ ì˜ì—­ì˜ í¬ê¸° (300x300)ì™€ ì¤‘ì‹¬ ì¢Œí‘œ, ë°˜ì§€ë¦„ 150
          const radius = 250;
          
          // ë³´ìŠ¤ ì¶©ëŒ ì²˜ë¦¬ (ì› í˜•íƒœ ì¶©ëŒ ê²€ì¦)
          
          
          // ëª¬ìŠ¤í„° ì¶©ëŒ ì²˜ë¦¬ (ê° ëª¬ìŠ¤í„°ì˜ ì¤‘ì•™ê³¼ ì› í˜•íƒœ ì¶©ëŒ ê²€ì‚¬)
          monsters.forEach(mon => {
            // ëª¬ìŠ¤í„° ì¤‘ì•™ ì¢Œí‘œ (mill offset: 50ì€ ì˜ˆì‹œê°’, ì‹¤ì œ ëª¬ìŠ¤í„° í¬ê¸°ì— ë§ê²Œ ì¡°ì ˆ)
            const monCenterX = mon.x + 50;
            const monCenterY = mon.y + 50;
            const dxMon = monCenterX - centerX;
            const dyMon = monCenterY - centerY;
            const distMon = Math.sqrt(dxMon * dxMon + dyMon * dyMon);
            
            if (distMon <= radius) {
              // ëª¬ìŠ¤í„°ì—ê²Œ ë°ë¯¸ì§€ ì ìš©
              mon.currentHealth -= 50;
              updateMonsterHealthBar(mon);
              mon.alive = false;
              mon.container.style.display = "none";
              createIceParticles(monCenterX, monCenterY);
              killCount++;
              killDisplay.textContent = killCount;
              
              // ì¼ì • ì‹œê°„ í›„ ëª¬ìŠ¤í„° ë¦¬ìŠ¤í°
              setTimeout(() => {
                mon.x = Math.random() * (gameWidth - 100);
                mon.y = Math.random() * (gameHeight - 100);
                mon.frame = 0;
                mon.chasing = false;
                mon.alive = true;
                mon.container.style.display = "block";
              }, 1500);
            }
            
            // (ì¶”ê°€) ì²´ë ¥ì´ 0 ì´í•˜ì¸ ê²½ìš° ì²˜ë¦¬ (ì´ë¯¸ ìœ„ì—ì„œ ì²˜ë¦¬ë¨)
          });
  
  // ìŠ¤í‚¬ íš¨ê³¼ëŠ” 200ms í›„ ìˆ¨ê¹€ ì²˜ë¦¬ (í•„ìš”ì— ë”°ë¼ ì¡°ì ˆ)
  setTimeout(() => {
    skillEffect2.style.display = "none";
  }, 1000);
  
  // ì¿¨ë‹¤ìš´ ì‹œê° íš¨ê³¼ ì²˜ë¦¬
  skillCooldown2.style.height = "100%";
  let elapsed2 = 0;
  const cooldownInterval2 = setInterval(() => {
    elapsed2 += 100;
    const percent = Math.max(0, 100 - (elapsed2 / cooldownDuration) * 100);
    skillCooldown2.style.height = percent + "%";
    
    if (elapsed2 >= cooldownDuration) {
      clearInterval(cooldownInterval2);
      skillCooldown2.style.height = "0%";
    }
  }, 100);
  if (killCount >= 50 && !bossSpawned) {
    spawnBoss();
  }
  // ì¿¨ë‹¤ìš´ í›„ ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥
  setTimeout(() => { canUseSkill2 = true; }, cooldownDuration);
}



          
      function handleKeydown(e) {
        if (e.repeat) return;

        let newX = posX;
        let newY = posY;

        if (e.code === "ArrowLeft") {
          newX -= speed;
          directionY = 2;
        } else if (e.code === "ArrowRight") {
          newX += speed;
          directionY = 3;
        } else if (e.code === "ArrowUp") {
          newY -= speed;
          directionY = 1;
        } else if (e.code === "ArrowDown") {
          newY += speed;
          directionY = 0;
        } else if (e.code === "KeyQ" && canUseSkill) {
          useSkill();
          return;
        }
        else if (e.code === "KeyW" && canUseSkill2) {
          useSkill2();
          return;
      }
      else if (e.code === "KeyE" && canUseSkill2) {
          useSkill3();
          return;
      }

        // âœ… ê²½ê³„ ì²´í¬ (ìºë¦­í„°ê°€ ë°•ìŠ¤ ë°–ìœ¼ë¡œ ì•ˆ ë‚˜ê°€ê²Œ ì œí•œ)
        const maxX = gameWidth - 58;
        const maxY = gameHeight - 117;

        if (newX >= 0 && newX <= maxX && newY >= 0 && newY <= maxY) {
          posX = newX;
          posY = newY;
          frame = (frame + 1) % 4;
          updateCharacter();
        }
      }

    
      function updateTimer() {
        const minutes = Math.floor(remainingTime / 60);
        const seconds = remainingTime % 60;
        timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        if (remainingTime <= 0) {
          clearInterval(timerInterval);
          endGame();
        }
        remainingTime--;
      }
    
      function endGame() {
        message.textContent = " GAME OVER ";
        message.style.display = "block";
        gameOverUI.style.display = "flex";
        window.removeEventListener("keydown", handleKeydown);
      }
    
      restartBtn.addEventListener("click", () => {
        killCount = 0;
        remainingTime = 180;
        currentHP = maxHP;
        killDisplay.textContent = killCount;
        timerDisplay.textContent = "3:00";
        updateHPBar();
        message.style.display = "none";
        gameOverUI.style.display = "none";
        monsters.forEach(mon => {
          mon.x = Math.random() * (gameWidth - 100);
          mon.y = Math.random() * (gameHeight - 100);
          mon.frame = 0;
          mon.chasing = false;
          mon.alive = true;
          mon.container.style.display = "block";
        });
        updateCharacter();
        updateMonsters();
        window.addEventListener("keydown", handleKeydown);
        clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
      });
    
      exitBtn.addEventListener("click", () => {
        gameOverUI.innerHTML = "<div style='color: white; font-size: 20px;'>ê²Œì„ì„ ì¢…ë£Œí•˜ì˜€ìŠµë‹ˆë‹¤.</div>";
      });
    
      timerInterval = setInterval(updateTimer, 1000);
      window.addEventListener("keydown", handleKeydown);
      setInterval(updateMonsters, 200);
      setInterval(moveMonsters, 500);
      updateCharacter();
      updateMonsters();
      updateHPBar();
    </script>
    
  </body>
  
  
  
</html>